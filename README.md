# relations_project
The library to proceed with relations (task #6, discrete math).

### I. Алгоритми та використані принципи дискретної математики:
1) **read_relation, write_relation** - використані стандартні знання, отримані на курсі з ОП: інструкція with open для відкриття файлу, if-умови, цикли, зрізи.
2) **get_reflexive_closure** - було використано означення рефлексивного відношення, спосіб отримання з відношення його рефлексивного замикання, а саме: доповнення його дельта-відношенням. В алгоритмі кожному і-тому-і-тому елементу матриці було присвоєно значення 1.
3) **get_symmetric_closure** - було використано означення симметричного відношення, спосіб отримання симетричного замикання, а саме: доповнення відношення оберненим йому відношенням. Тому в алгоритмі якщо кожний і-тий-j-тий елемент має значення 1, то й кожному j-тому-і-тому елементу присвоюється 1.
4) **get_transitive_closure** - для розробки цієї функції було використано алгоритм Уоршалла: для кожного елементу матриці залишаємо його попереднє значення, якщо шляха між умовними i та j через k не існує, або 1, якщо існує. Складність алгоритму О(n^3).
5) **is_transitive** - для перевірки, чи відношення транзитивне, було використано теорему: якщо відношення дорівнює своєму транзитивному замиканню, то це відношення транзитивне. Для знаходження замикання використаний знову алгоритм Уоршалла, який переривається при знаходженні хоча б одної невідповідності.
6) **is_transitive_alternative** - ще одна версія функції для визначення, чи відношення транзитивне. Вона працює з відношенням заданим у вигляді масиву таплів (множини упорядкованих пар), адже функція **get_number_of_transitive** працює з відношенням саме в такому форматі. Тут було використано означення транзитивного відношення: якщо пари (a, b) та (b, c) є у відношенні, то й пара (a, c) також є. Алгоритм: проходить по кожній парі у відношенні, маючи список других елементів кожної пари (елементів с) та перевіряє на транзитивність кожний випадок.
7) **get_equivalence_classes** - використано означення класу еквівалентності для конкретного елементу а: це множина таких елементів х, що aRx. Тут множина, на якій задано відношення R, вважається А = {0, 1, 2, ...}. Алгоритм: створюємо словник класів еквівалетності, де ключ - елемент, для якого створений клас еквівалентності, значення - сет (спочатку пустий, потім заповнений на основі даних з матриці), що репрезентує клас.
8) **get_number_of_transitive** - використана властивість транзитивності декартового квардату.
##### Алгоритм:
1. Створення декартового квардрату множини з n елементами (у форматі списку таплів).
2. Створення бінарного сету з n^2 нулів. Тут 0 - відсутність відповідної пари в декартовому квадраті, 1 - присутність. Якщо значення стає 2, то завдяки циклу наступне значення стає 1, а поточне - 0. Таким чином можна перебрати всі підмножини А^2.
3. На основі бінарного сету складається відношення й перевіряється його транзитивнсть завдяки **is_transitive_alternative**.
4. Якщо в бінарному сеті не залишиться жодного нуля, то цикл переривається й повертається підрахована кількість транзитивних відношень.

### II. Процес виконання й використання проекту, розподіл роботи:
#### Хід роботи:
1) Перша зустріч: розбір завдань і **розподіл роботи** (тему було визначено ще до зустрічі):

прим. *розробка функції* - розробка ефективного робочого алгоритму, написання документації й доктестів.

Антон Мазурик - розробка **get_number_of_transitive**, "чистка" коду (виправлення документації, додавання коментарів, дотримання вимог PEP8).

Марія Плис - розробка **is_transitive_alternative**, написання частини звіту.

Надія Заячковська - розробка **get_reflexive_closure**, **get_symmetric_closure** та **get_equivalence_classes**.

Дарина Чебан - розробка **get_transitive_closure**.

Дмитро Калітін - розробка **read_relation, write_relation** та **is_transitive**. Створення репозиторію, злиття функцій, написання частини звіту.

2) Друга зустріч, частина перша: зливаємо разом наші функції (перевірка на баги на малих обсягах даних), пояснюємо алгоритми.
3) Друга зустріч, частина друга: тестуємо алгоритми на великих обсягах даних, за необхідності збільшуємо ефективність.
4) Третя зустріч: фінальні штрихи: додаткова перевірка коду, "чистка", написання звіту, здача проекту.

### III. Загальні враження й фідбеки:
